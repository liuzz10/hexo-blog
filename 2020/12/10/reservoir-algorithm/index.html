<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>Reservoir Algorithm (R, X and Y) | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<script src='https://unpkg.com/valine@1.4.16/dist/Valine.min.js'></script>



  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            strawberrybfs&#39;s blog
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/tag/">Tags</a>
              </li> 
                   
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/algorithm/">
                            algorithm
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/reservoir/">
                            reservoir
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                Reservoir Algorithm (R, X and Y)
            
            
        </div>
        <span class="post-date">
            Dec 10, 2020
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>The problem is to select a random sample of size n from a set of size N with following limitation:</p>
<ul>
<li>N is not given and we can’t generate any knowledge of N. Hence, it needs to be finished in one pass since N is not known.</li>
<li>Every element of N has the same probabilities to be selected (this is what “random sample” requires)</li>
</ul>
<p>If N is known, it’s relatively easy to do random sampling - we will just need to generate n random numbers from[1, N]. If N is not known, how do we make sure each element will be selected with the same probability?</p>
<p>This problem occurs frequently in the real world. For example, to select 1000 words from a super thick dictionary whose total number of words is not known. To select 300 samples from an ongoing data stream and we don’t know when the stream will end. Therefore, optimizing this problem will help with solving these problems.</p>
<h1 id="Reservoir-Algorithms"><a href="#Reservoir-Algorithms" class="headerlink" title="Reservoir Algorithms"></a>Reservoir Algorithms</h1><p>Reservoir algorithms are the solution to the above random sampling problem which needs to be finished in one pass. In other words, the time complexity is O(N). A “reservoir” is created to temporarily store candidates of samples that we should only keep track of. The size of the reservoir can be larger than n or equals to n.</p>
<p>Algorithm R, X, and Y all major players in reservoir algorithms. The following table is a brief comparison on their performance.</p>
<p><img src="table.png" alt="comparison table"></p>
<h1 id="Algorithm-R"><a href="#Algorithm-R" class="headerlink" title="Algorithm R"></a>Algorithm R</h1><p>Both the algorithm itself and proof are pretty elegant. I will first describe the algorithm and then give a proof about the correctness of it.</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>When we are processing the kth number K:</p>
<ul>
<li>If Kn, which means that it’s one of the first n numbers,<ul>
<li>Add it to the reservoir directly.</li>
</ul>
</li>
<li>If K&gt;n, which means that it’s after the first n numbers,<ul>
<li>Generate a random number Rfrom[1, N].</li>
<li>If Rn , which means that there must be an corresponding Rth number in the reservoir of n numbers. Then we replace the Rth number with K.</li>
</ul>
</li>
<li>Process the next number with the same steps as above until reaching N.</li>
</ul>
<p><strong>Time complexity.</strong> The time complexity is O(N) because we will need to scan every number for exactly one time and it takes constant time to process each number.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Given an array [1, 2, 3, 4…], we are selecting a random sample of size 3. So in this example n = 2.</p>
<p>When we are processing 1 and 2, we can simply place numbers into the reservoir. If the streaming ends at 2, each number will have the same probability of 1 to be selected.</p>
<p>The reservoir is [1, 2] now. When we are processing 3, we will calculate a random number R from [1, 3]. If R is 1, we will replace 1 with 3 so that the reservoir will be [3, 2]. In this case, the probability of 3 being placed to the reservoir is 2/3. The probability of 1 or 2 being kept in the reservoir is 1 - 2/3 * 1/2 = 2/3 which is the same.</p>
<p>The reservoir is [3, 2] now. When we are processing 4, we will calculate a random number R from [1, 4]. If R is 2, we will replace 2 with 4 so that the reservoir will be [3, 4]. In this case, the probability of 4 being placed to the reservoir is 2/4. The probability of 3 or 2 being kept in the reservoir is 2/3 _ (1 - 2/4 _ 1/2) = 2/4 which is the same.</p>
<p>It will keep the same pattern when we are processing 5, 6, 7…. I will provide a proof as follows.</p>
<h2 id="Proof-by-induction"><a href="#Proof-by-induction" class="headerlink" title="Proof by induction"></a>Proof by induction</h2><p><strong>Notation.</strong> when we are processing the ith number (to decide to include in the reservoir or not), we use the following notations to represent the event and probability:</p>
<ul>
<li><p>Xi: a random variable that represents the event to include the ith number in the reservoir or not.</p>
</li>
<li><p>Xi takes 2 values:</p>
<ul>
<li>Xi=1: the ith number is included in the reservoir</li>
<li>P(Xi=1): the probability of the ith number being included in the reservoir</li>
<li>Xi=0: the ith number is not included in the reservoir</li>
<li>P(Xi=0): the probability of the ith number not being included in the reservoir</li>
<li>P(Xi=1) + P(Xi=0)=1</li>
</ul>
</li>
</ul>
<p><strong>Proof</strong></p>
<ul>
<li><p>When i n, the probability of the ith number being included in the reservoir is</p>
<p>P(Xi=1) = 1</p>
<p>or we can say</p>
<p>P(X1=1) = P(X2=1) = ······ = P(Xi=1) = 1</p>
</li>
<li><p>When i &gt; n, the probability of the ith number being included in the reservoir is</p>
<p>P(Xi=1) = n/i</p>
<p>or we can say</p>
<p>P(X1=1) = P(X2=1) = ······ = P(Xi=1) = n/i</p>
<ul>
<li>We assume that it’s true and want to prove that the i+1th number also holds true. In other words, we are proving</li>
</ul>
<p>P(X1=1) = P(X2=1) = ······ = P(Xi+1=1) = n/(i+1)</p>
</li>
<li><p>When i=i+1, the probability of the (i+1)th number being selected to the reservoir is</p>
<p>P(Xi+1=1) = n/(i+1)</p>
<p>Part of the above equation is proved. Now we need to prove that the probability of the current numbers in reservoir being kept in the reservoir is n/(i+1) too since each number shall share the same probability to be selected to the reservoir.</p>
<ul>
<li><p>The probability of the current numbers in reservoir not being changed at this iteration is</p>
<p>1 - P(Xi+1=1) * (1/n)</p>
<p>1/n is the probability that a specific number in the reservoir is being selected under the condition that the (i+1)th number got the ticket to the reservoir.</p>
</li>
<li><p>The total probability of the current numbers in reservoir not being changed after all iterations is the above probability times P(Xi=1)</p>
<p>P(X1=1) = P(X2=1) = ······<br>= P(Xi=1) _ (1 - P(Xi+1=1) _ (1/n))<br>= (n/i) _ (1 - n/(i+1) _ (1/n))<br>= n/(i+1)</p>
</li>
<li><p>The algorithm is proved since it makes sure every number can be selected at the same probability. Elegant?</p>
</li>
</ul>
</li>
</ul>
<h1 id="Algorithm-X-and-Y"><a href="#Algorithm-X-and-Y" class="headerlink" title="Algorithm X and Y"></a>Algorithm X and Y</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Algorithm R has to calculate random numbers from [1, n] for n-k times which can be optimized. The core of Algorithm R is the random number generator which makes some numbers gaining the “ticket” to go to the reservoir(when Xi=1) while some don’t(when Xi=0). If the generator “kicks out” some numbers, that means there are some numbers that wouldn’t get the “ticket” to get into the reservoir in the end, why don’t we skip these numbers at the very beginning?</p>
<p>If we can calculate how often a “lucky” number occurs, we can simply jump to this “lucky” number and skip all before it since we only need to place it in the reservoir. Algorithm X and Y does this.</p>
<h1 id="Common-Pattern"><a href="#Common-Pattern" class="headerlink" title="Common Pattern"></a>Common Pattern</h1><p>Algorithm X and Y optimize algorithm R in the times of calling the function that generates a random number. It “predicts” where the next lucky number is and is followed by following steps:</p>
<ul>
<li>Calculate how many numbers we shall skip: (n, i).</li>
<li>Skip (n, i) numbers.</li>
<li>Randomly select a number in the reservoir and replace it with the next number (the “lucky” number).</li>
<li>Repeat the above steps until the last number.</li>
</ul>
<p>How to calculate <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.253ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2763.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D719" d="M409 688Q413 694 421 694H429H442Q448 688 448 686Q448 679 418 563Q411 535 404 504T392 458L388 442Q388 441 397 441T429 435T477 418Q521 397 550 357T579 260T548 151T471 65T374 11T279 -10H275L251 -105Q245 -128 238 -160Q230 -192 227 -198T215 -205H209Q189 -205 189 -198Q189 -193 211 -103L234 -11Q234 -10 226 -10Q221 -10 206 -8T161 6T107 36T62 89T43 171Q43 231 76 284T157 370T254 422T342 441Q347 441 348 445L378 567Q409 686 409 688ZM122 150Q122 116 134 91T167 53T203 35T237 27H244L337 404Q333 404 326 403T297 395T255 379T211 350T170 304Q152 276 137 237Q122 191 122 150ZM500 282Q500 320 484 347T444 385T405 400T381 404H378L332 217L284 29Q284 27 285 27Q293 27 317 33T357 47Q400 66 431 100T475 170T494 234T500 282Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path><path id="MJX-1-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D719" xlink:href="#MJX-1-TEX-I-1D719"></use></g><g data-mml-node="mo" transform="translate(596,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(985,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(1585,0)"><use data-c="2C" xlink:href="#MJX-1-TEX-N-2C"></use></g><g data-mml-node="mi" transform="translate(2029.7,0)"><use data-c="1D456" xlink:href="#MJX-1-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(2374.7,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container> ? We will need to get its cumulative distribution function F(s)=P($\phi$&lt;=s), which is the probability to skip numbers less than or equals to s when we are on the ith number. That equals to the counterpart which is 1-P($\phi$&gt;s). What is P($\phi$&gt;s)? That is the probability if we skip more than s numbers so it’s the probability when all numbers from (i+1)th number to (i+1+s)th number are not selected.</p>
<p>Therefore,<br>F(s)=P($\phi$&lt;=s)=1-P($\phi$&gt;s)<br>=1-(1-n/(i+1))(1-n/(i+2))···(1-n/(i+s+1))<br>=1-(i+1-n)(i+2-n)···(i+s+1-n)/(i+1)(i+2)···(i+s+1)<br>=1-(i+1-n)(i+2-n)···(i+s+1-n)/(i+1)(i+2)···(i+s+1)</p>
<p>How to find s that satisfying the above function? We can make use of inverse transform sampling. Yes it will help us to randomly generate an s that satisfies the distribution.</p>
<p>To do inverse transform sampling, we need an inverse function of F(s) which is F-1(U). Since $F(s) \in [0, 1]$, $U \in [0, 1]$as well. Therefore with a randomly generated U we are able to find a specific s which satisfies the distribution F(s) and thus we find the minimized number of elements to skip.</p>
<p>Therefore, we will only need to solve the following inequation where Uis randomly generated from[0, 1]:</p>
<p>(i+1-n)(i+2-n)···(i+s+1-n)/(i+1)(i+2)···(i+s+1) &lt;= 1-U (1.1)</p>
<p>where i, n, Uare all known and the goal is to get s. Since the left-hand side of the inequation is so complicated, we will need to think about how to solve the inequation. The key difference between X and Y is the way to solve the inequation. With the s generated, they share the same steps as I listed above.</p>
<h2 id="Algorithm-X"><a href="#Algorithm-X" class="headerlink" title="Algorithm X"></a>Algorithm X</h2><p>To solve inequation (1.1), we can use a brute force solution Algorithm X. It finds s by sequentially search for the minimum s, trying out all values in an increasing order until reaching the critical value. Therefore, the whole procedure of Algorithm X is:</p>
<ul>
<li>Generate a random number $u \in [0, 1]$.</li>
<li>Search sequentially for the minimum s &gt;= 0 such that F(s) &lt;= u.</li>
<li>Skip s numbers.</li>
<li>Randomly select a number in the reservoir and replace it with the next number (the “lucky” number).</li>
<li>Repeat the above steps until the last number.</li>
</ul>
<p><strong>Time complexity.</strong> It’s faster than Algorithm R since it generates the random number only one time after the generation of $\phi$, compared to calling $\phi$ times after the generation of $\phi$ in Algorithm R. However, the time complexity of Algorithm X is O(N)in average because the sequential search takes O($\phi$+1)time.</p>
<h2 id="Algorithm-Y"><a href="#Algorithm-Y" class="headerlink" title="Algorithm Y"></a>Algorithm Y</h2><p>Algorithm Y shares the same idea with Algorithm X in terms of the goal of generating how many numbers to skip. It uses Newton’s interpolation method to solve inequation (1.1) in order to find the minimum s. I will not give the detailed proof on this method here. The idea is to turn the inequation (1.1) to a new equation as below and find the “approximate root” of equation,</p>
<p>(i+1-n)(i+2-n)···(i+s+1-n)(i+1)/(i+2)···(i+s+1)$\approx$ 1-U</p>
<p><strong>Time complexity.</strong> With the help of Newton’s method, this is faster than sequentially searching for an s. It converges to get s in O(1+loglog$\phi$)iterations. Therefore the average running time would be O(n^2*(1+log(N/n)loglog(N/n)))on which the author provided a wonderful proof.</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>The author also developed a faster Algorithm Z in the end but I will not discuss it in this article since it’s faster than Algorithm Y by a polynomial factor (it’s great, but…let’s focus on Y). A big jump is from Algorithm R to Algorithm Y with:</p>
<ul>
<li>The idea of skipping numbers and,</li>
<li>The usage of Newton’s interpolation method to find out the proper number of elements to skip during each iteration.</li>
</ul>
<p>To sum up, a series of reservoir algorithms such as R, X, and Y were developed and were optimized. All of them need to create a reservoir to temporarily store correct samples in case that it’s needed at any time (i.e., the date stream ends at any time and the reservoir will be able to provide the correct result correspondingly).</p>
<p>R decides whether to place the number into the reservoir on EVERY number so the running time is not that optimal (but still decent!). X and Y only decide whose destiny is “in” so it skips those unlucky guys. Moreover, Y optimizes on the algorithm to find those lucky guys so the running time is the optimal among them.</p>
<p><strong>Reference</strong><br>Vitter, J. S. (1985). Random sampling with a reservoir. ACM Transactions on Mathematical Software (TOMS), 11(1), 37-57.</p>
<p><a target="_blank" rel="noopener" href="https://nbviewer.jupyter.org/github/jameslao/Algorithmic-Pearls/blob/master/ReservoirSampling.ipynb">https://nbviewer.jupyter.org/github/jameslao/Algorithmic-Pearls/blob/master/ReservoirSampling.ipynb</a></p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2021/01/10/lc-11-container/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2020/09/09/lc-134-gas-station/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

    
        <div id="disqus_thread"></div>
        <script>
            /**
            *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
            *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
            
            var disqus_config = function () {
                this.page.url = 'http://liuzz10.github.io/2020/12/10/reservoir-algorithm/';  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = '2020/12/10/reservoir-algorithm/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                this.language = 'en'
            };
            
            (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://joyblogs.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>   
     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
  <div class="flex-container">
    <div class="footer-text">
        © 2021 Zhuozhuo Liu 
      <!--      -->
       &nbsp; | &nbsp; 我见青山多可爱，料青山见我应如是 
    </div>
  </div>
</div>


    </div>

  </body>
</html>
